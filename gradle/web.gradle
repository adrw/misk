import groovy.json.JsonSlurper

def dockerMiskWebImage = "squareup/misk-web"
def dockerMiskWebVersion = "0.0.6"

task web(type: Exec) {
  // -Pcmd='-d': pass in argument to misk-web shell script in Docker container
  // -Ptabs='tabs/config, tabs/example': spins up parallel Docker containers with the following paths as volumes
  // -Pdockerd: boolean to run Docker container as daemon in background
  // Running webpack-dev-servers for various tabs: ./gradlew web -Pcmd='-d' -Ptabs='tabs/config, tabs/example'
  // Build all tabs: ./gradlew web
  // See other misk-web options: ./gradlew web -Pcmd='-h'

  def projectName = project.projectDir.toString().split('/').dropRight(1).last()
  def subProjectName = project.projectDir.toString().split('/').last()

  def strToSlug = { str ->
    def slug = str.split('/').join('-').split('@').join('')
    if (slug.startsWith('-')) {
      slug = slug.drop(1)
    }
    if (slug == "") {
      slug = "container"
    }
    return slug
  }

  def strToPrefixSlug = { str, prefix = "-" ->
    def slug = strToSlug(str)
    def prefixSlug = ""
    if (slug != "") {
      prefixSlug = "${prefix}${slug}"
    }
    return prefixSlug
  }

  def generateDockerContainerName = { task, prefix = "web" ->
    return "${new Date().format("YMD-HMS")}-${projectName}-${subProjectName}-${prefix}${strToPrefixSlug(task)}"
  }

  def getPackageJsonPort = { path ->
    try {
      def packageFile = new File("$path/package.json")
      def packageJson = new JsonSlurper().parseText(packageFile.text)
      return packageJson.miskTab.port
    } catch (all) {
      return null
    }
  }

  def getPackageDockerImage = { path ->
    try {
      def packageFile = new File("$path/package.json")
      def packageJson = new JsonSlurper().parseText(packageFile.text)
      return packageJson.miskTab.dockerImage
    } catch (all) {
      return null
    }
  }

  def getPackageVersion = { path ->
    try {
      def packageFile = new File("$path/package.json")
      def packageJson = new JsonSlurper().parseText(packageFile.text)
      return packageJson.miskTab.version
    } catch (all) {
      return null
    }
  }

  def generateDockerRunCommand = {
    projectPath, path, cmd, daemon = "-d", prefix = "web" ->
      def containerName = "${generateDockerContainerName(path, prefix)}"
      def port = ""
      if (path.startsWith("/tabs")) {
        port = "-p ${getPackageJsonPort("${projectPath}/web/${path}")}:${getPackageJsonPort("${projectPath}/web/${path}")}"
      }
      def image = getPackageDockerImage("${projectPath}/web/${path}")
      if (image == null) {
        image = dockerMiskWebImage
      }
      def versionWarningLog = ""
      def imageVersion = getPackageVersion("${projectPath}/web/${path}")
      if (imageVersion == null) {
        imageVersion = dockerMiskWebVersion
      } else {
        if (imageVersion < dockerMiskWebVersion) {
          def versionWarning = "\n[WARN] Upgrade miskTab.version ${imageVersion} -> ${dockerMiskWebVersion} in ${path}/package.json\nCheck for breaking changes and upgrade to latest @misk/ packages: https://github.com/square/misk/tree/master/docker/misk-web\n"
          versionWarningLog = "; echo '$versionWarning'"
          println versionWarning
        }
      }
      def command = "docker run ${daemon} --rm --name ${containerName} -v ${projectPath}/web${path}:/web${path} ${port} ${image}:${imageVersion} ${cmd}"
      def logsDir = "${projectPath}/web/logs/"
      println "\nContainer: ${containerName} ${cmd}"
      println "Running... \$ ${command}"
      println "Logs       \$ docker logs -f ${containerName}"
      println "Logs File  ${logsDir}${containerName.toString()}.log"
      println "Shut Down  \$ docker kill ${containerName}"
      def waitForContainer = "while ! docker ps --format '{{.Names}}' | grep -q '${containerName}'; do sleep 1; done"
      def formattedLogs = "mkdir -p $logsDir && bash -c \'docker logs -f ${containerName} | tee \"${logsDir}${containerName.toString()}.log\" > >(sed \"s/^/[${strToSlug(path)}] /\") 2> >(sed \"s/^/[${strToSlug(path)}][err] /\" >&2) &\'"
      return "sh -c '$command &'; $waitForContainer && $formattedLogs $versionWarningLog"
  }

  def cmd = ""
  if (project.hasProperty("cmd")) {
    cmd = project.cmd
  } else {
    cmd = "-g"
  }

  def dockerd = ""
  if (project.hasProperty("dockerd")) {
    dockerd = "-d"
  }

  // Ensure local node_modules present and up to date
  def runCommand = generateDockerRunCommand(project.projectDir, "", "/bin/misk-web -r", "-d",
          "node-modules")

  if (project.hasProperty("tabs")) {
    if (project.tabs.split(',').length > 1) {
      dockerd = "-d"
    }

    project.tabs.split(',').each {
      def command = generateDockerRunCommand(project.projectDir, "/$it", "/bin/misk-web ${cmd}",
              dockerd)
      if (runCommand != "") {
        runCommand += " && "
      }
      runCommand += command
    }
  } else if (cmd == '-r') {
    runCommand += ""
  } else {
    // Spin up parallel images for all @misk/ packages and tabs
    def paths = []
    try {
      new File("${project.projectDir}/web/@misk").eachDir {
        paths += it.toString().split('/web/').drop(1)[0]
      }
    } catch (all) {
      println "Can't find any @misk packages in ${project.projectDir}/web/@misk"
    }
    try {
      new File("${project.projectDir}/web/tabs").eachDir {
        paths += it.toString().split('/web/').drop(1)[0]
      }
    } catch (all) {
      println "Can't find any tabs in ${project.projectDir}/web/tabs"
    }

    if (paths.size() > 1) {
      dockerd = "-d"
    }

    paths.each {
      def command = generateDockerRunCommand(project.projectDir, "/$it", "/bin/misk-web ${cmd}",
              dockerd)
      if (runCommand != "") {
        runCommand += " && "
      }
      runCommand += command
    }
  }

  def sleepUntilDockerExits = "while docker ps --format '{{.Names}}' | grep -q '${projectName}-${subProjectName}-web'; do echo -e \"\\r\\033[1A\\033[0K[\$(date +'%Y-%m-%d %T')] waiting for [\$(docker ps --format '{{.Names}}' | grep '${projectName}-${subProjectName}' | wc -l | tr -d '\t')] *${projectName}-${subProjectName}-web* running containers to finish...\" && sleep 2; done"
  runCommand += " && ${sleepUntilDockerExits}"
  commandLine 'sh', '-c', runCommand
}
